<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>
    Class Based Views // cat /dev/random
  </title>

  <link href="http://gmpg.org/xfn/11" rel="profile">
<meta http-equiv="content-type" content="text/html; charset=utf-8">


<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

<meta name="description" content="Django&#39;s Class Based Views in Flask">
<meta name="keywords" content="">
<meta name="author" content="">


  <meta property="og:title" content="Class Based Views" />
<meta property="og:description" content="Django&#39;s Class Based Views in Flask" />
<meta property="og:type" content="website" />
<meta property="og:locale" content="en_US" />
<meta property="og:url" content="http://192.241.186.225/articles/2013-05-09-class-based-views/" />


  <link href='http://fonts.googleapis.com/css?family=Raleway:400,300,600' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="http://192.241.186.225/css/normalize.css">
  <link rel="stylesheet" href="http://192.241.186.225/css/skeleton.css">
  <link rel="stylesheet" href="http://192.241.186.225/css/main.css">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="cat /dev/random" />

  
  <link rel="stylesheet" href="http://192.241.186.225/css/highlight/railscasts.css">
  <script src="https://yandex.st/highlightjs/8.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  
</head>


<body>
  <div class="container">
    <div class="row">

      <div class="content">
      

  		<section class="post">
            <h1 class="post-title">
              <a href="/articles/2013-05-09-class-based-views/">Class Based Views</a>
            </h1>
            <h3 class="post-subtitle">
            	
            </h3>

        
          <small class="post-date-day">Published on 1</small>
          <small class="post-date-month">January, </small> 
          <small class="post-date-year">0001</small>
        

			
			

			
				<div class="tags-list">
					<span class="dark-red">Tags</span><span class="decorative-marker">//</span>
					
            <a class="post-tag post-tag-python" href="http://192.241.186.225/tags/python">python</a>,
          
            <a class="post-tag post-tag-flask" href="http://192.241.186.225/tags/flask">flask</a>,
          
            <a class="post-tag post-tag-django" href="http://192.241.186.225/tags/django">django</a>,
          
				</div>
			

			

			

            

<p>If you&rsquo;ve used Django before, one of the things that you surely miss (apart from the django-admin, of course) is class based (or generic) views. Class based views allow you to structure your views and reuse code by harnessing inheritance and mixins. This allows you to create generic views for routine tasks and simply inherit from them for similar views.</p>

<p>In flask 0.7 class based views were introduced which act similar to generic
views in Django. In this tutorial we&rsquo;ll cover how to use class based views to
make extendable views. We&rsquo;ll also see how we can use <code>MethodView</code> (a type of
class based view) to create a RESTful API.</p>

<p>Lets get started. I have a basic starter template that looks like this -</p>

<p>{% highlight python %}
|&ndash; static/
    |- jquery.js
|&ndash; templates/
    |&ndash; index.html
    |&ndash; about.html
    |&ndash; base.html
    |&ndash; users.html
|&ndash; main.py
|&ndash; user.db
{% endhighlight %}</p>

<p>Since the app is only for demo purposes, I&rsquo;ve added all my models and views in a
single file - <code>main.py</code>. I have a single model called <code>User</code> and I&rsquo;ve used SQLAlchemy as the ORM. The <code>user.db</code> file is the SQLITE db that I&rsquo;m using for this app. To begin with, these are the kinds of views that our app needs to have -</p>

<ol>
<li>There are a few views that simply need to return a template - like index and about.</li>
<li>There are a couple of models in our application and we need to have views that display
the model data as a list by passing that data to a template.</li>
<li>Lastly, we need to have consolidated view for making a API instead of flooding
our view with ifs</li>
</ol>

<p>{% highlight python %}
@app.route(&lsquo;/users/&rsquo;)
def users():
  if request.method == &ldquo;GET&rdquo;:
    pass
  else:
    pass<br />
{% endhighlight %}</p>

<p>{% highlight python %}
@app.route(&lsquo;/users/<a href="int:post_id">int:post_id</a>&rsquo;)
def user():
  if request.method == &ldquo;GET&rdquo;:
    pass
  elif request.method == &ldquo;PUT&rdquo;:
    pass
  elif request.method == &ldquo;DELETE&rdquo;:
    pass
{% endhighlight %}</p>

<p>Lets begin with the first requirement. Instead of just repeating code to
render a template we&rsquo;ll a create class based view akin to a <a href="https://docs.djangoproject.com/en/dev/ref/class-based-views/base/#django.views.generic.base.TemplateView">TemplateView</a> in
django</p>

<p>{% highlight python %}
from flask.views import View</p>

<p>class RenderTemplateView(View):
    def <strong>init</strong>(self, template_name):
        self.template_name = template_name</p>

<pre><code>def dispatch_request(self):
    return render_template(self.template_name)
</code></pre>

<p>{% endhighlight %}</p>

<p>What we&rsquo;ve done here is that we&rsquo;ve just subclassed the <code>flask.views.View</code> class
and implemented a <code>dispatch_request</code> method. All subclasses that inherit from the
<code>flask.view</code> class need to override this method to implement the actual view
code.</p>

<p>This allows us to create template views like this -</p>

<p>{% highlight python %}</p>

<h1 id="urls-for-rendering-simple-templates:500547a4dcb2c1f7f0b3455a9db17249">urls for rendering simple templates</h1>

<p>app.add_url_rule(&lsquo;/about&rsquo;, view_func = RenderTemplateView.as_view(&lsquo;about_page&rsquo;, template_name=&ldquo;about.html&rdquo;))
app.add_url_rule(&lsquo;/&rsquo;, view_func = RenderTemplateView.as_view(&lsquo;index_page&rsquo;, template_name=&ldquo;index.html&rdquo;))
{% endhighlight %}</p>

<p>The first argument to the <code>as_view</code> function is the URL endpoint and second
being the name of the template that needs to be passed.</p>

<p>With that out of way, lets jump to the second requirement - building a listview.
Now in my app, I just have one model but in apps where there are lots of models
and you find yourself repeatedly implementing a view that returns a list of the
objects of that model which is then passed to a template, you can implement your
listview class. Lets see how that is done -</p>

<p>{% highlight python %}
class ListView(View):
    def get_template_name(self):
        raise NotImplementedError()</p>

<pre><code>def render_template(self, context):
    # a custom render_template method that passes in the 
    # template name and the modified template context
    return render_template(self.get_template_name(), **context)

def dispatch_request(self):
    # self.get_context returns a modified context which is
    # then passed to our render_template method
    context = self.get_context()
    return self.render_template(context)
</code></pre>

<h1 id="subclass-from-the-listview-class:500547a4dcb2c1f7f0b3455a9db17249">subclass from the listview class</h1>

<p>class UserListView(ListView):
    def get_template_name(self):
        return &ldquo;users.html&rdquo;</p>

<pre><code>def get_context(self):
    context = {'objects': User.query.all(), 'time': datetime.now()}
    return context
</code></pre>

<h1 id="urls-for-list-views:500547a4dcb2c1f7f0b3455a9db17249">urls for list views</h1>

<p>app.add_url_rule(&lsquo;/userlist/&rsquo;, view_func = UserListView.as_view(&lsquo;user_list&rsquo;))
{% endhighlight %}</p>

<p>The idea here is similar. We implmenent a custom <code>render_template</code> function so
that we can pass in a custom context to the template. This pattern can then be
easily extended for multiple models.</p>

<p>Lastly, lets see how we can use <code>MethodView</code> to make a RESTful API. <code>MethodView</code>
allows us to manage method-based dispatching like so -</p>

<p>{% highlight python %}
from flask.views import MethodView
class UserAPI(MethodView):
    def get(self, user_id):
        if user_id is None:
            users = User.query.all()
            json_results = [{&lsquo;name&rsquo;: u.name, &lsquo;age&rsquo;: u.age} for u in users]
        else:
            user = User.query.get_or_404(user_id)
            json_results = [{&lsquo;name&rsquo;: user.name, &lsquo;age&rsquo;: user.age}]
        return jsonify(item=json_results)</p>

<pre><code>def post(self):
  pass

def delete(self, user_id):
  pass

def put(self, user_id):
  pass
</code></pre>

<p>{% endhighlight %}</p>

<p>As you can see, each HTTP method maps to a function with the same name. This way
you dont have to provide separate <code>method</code> attribute as its automagically
deciphered from the title of the method.</p>

<p>To hook this up to a routing system we just provides multiple routes to the same
view like this -</p>

<p>{% highlight python %}</p>

<h1 id="urls-for-user-api:500547a4dcb2c1f7f0b3455a9db17249">urls for User API</h1>

<p>user_api_view = UserAPI.as_view(&lsquo;user_api&rsquo;)
app.add_url_rule(&lsquo;/users/&rsquo;, defaults={&lsquo;user_id&rsquo;: None},
                 view_func = user_api_view, methods=[&ldquo;GET&rdquo;,])
app.add_url_rule(&lsquo;/users/&rsquo;, view_func = user_api_view, methods=[&ldquo;POST&rdquo;,])
app.add_url_rule(&lsquo;/users/<a href="int:user_id">int:user_id</a>&rsquo;, view_func = user_api_view,
                 methods=[&ldquo;GET&rdquo;, &ldquo;PUT&rdquo;, &ldquo;DELETE&rdquo;])
{% endhighlight %}</p>

<p>If you&rsquo;ve been following along you can check the code on my <a href="https://github.com/prakhar1989/flask-tuts/tree/master/lesson-3">github</a> which contains a working API and accompanying jquery ajax calls for testing the API for your reference.</p>

<p>I hope this tutorial has helped you in understanding when you use class based
views. Basically, whenever you see yourself repeating view functionality you
know that its time for a class based view. Don&rsquo;t forget to refer to the
<a href="http://flask.pocoo.org/docs/views/">official docs</a> to get a clearer picture.</p>

<p>See you next time!</p>

	
			


			
				<div class="paging">
					<span class="paging-label">More Reading</span>
					
					<div class="paging-newer">
						<span class="dark-red">Newer</span><span class="decorative-marker">//</span>
						<a class="paging-link" href="/articles/2013-05-08-using-blueprints/">Using Blueprints</a>
		            </div>
		            

					
					<div class="paging-older">
						<span class="dark-red">Older</span><span class="decorative-marker">//</span>
			            <a class="paging-link" href="/articles/2013-05-06-beginning-flask/">Beginning Flask</a>
		            </div>
		            
	            </div>
            
          </section>

          
          	
          
        
      <div class="footer">
	<hr class="thin" />
	<div class="pure-menu pure-menu-horizontal pure-menu-open">
		<ul class="footer-menu">
		
		</ul>
	</div>

	<p>&copy; 2014. All rights reserved. </p>
</div>
    </div>
  </div>
	

	

  
    </div>
  </div>
</body>
</html>
