<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Angularjs on cat /dev/random</title>
    <link>http://192.241.186.225/tags/angularjs/</link>
    <description>Recent content in Angularjs on cat /dev/random</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
    
    <lastBuildDate>Sat, 02 Aug 2014 12:34:58 AST</lastBuildDate>
    <atom:link href="http://192.241.186.225/tags/angularjs/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Organizing Angular Apps for Testing</title>
      <link>http://192.241.186.225/articles/organizing-angular-apps-for-testing/</link>
      <pubDate>Sat, 02 Aug 2014 12:34:58 AST</pubDate>
      
      <guid>http://192.241.186.225/articles/organizing-angular-apps-for-testing/</guid>
      <description>

&lt;p&gt;In the &lt;a href=&#34;/articles/choosing-angular&#34;&gt;last post&lt;/a&gt;, I talked about how we moved away from jQuery to Angularjs to power our single page application. To recap, the major problems with our existing code which convinced us to do a rewrite -&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The existing code was written by a team which was no longer with the project. No one on the existing team had a strong understanding of how the code worked.&lt;/li&gt;
&lt;li&gt;Without any structure, the code was extremely hard to maintain and understand. Having a huge javascript file with more than 1500 lines of code was a complete nightmare.&lt;/li&gt;
&lt;li&gt;There were no tests at all which made refactoring a very hard exercise. Whenever a bug was reported the team used to be scared to break something that was already working.&lt;/li&gt;
&lt;li&gt;It used a technology (jQuery) which was totally not suited to the problem. This meant that adding any new features on the existing application would result in a lot more code which while using a better technology could be accomplished with much lesser.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Early on, my primary focus was to guard against these problems and as a result, I spent considerable time trying to understand the best practices in building a single page application.Below are a few practices that I decided to carry on as I start building this project&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Comprehensive documentation and well-commented code along with regular code reviews and walkthroughs with the rest of the team so that everyone has a good enough understanding of the application.&lt;/li&gt;
&lt;li&gt;Having an intuitive and scalable project structure, organized by modules in order to aid traversing the code and reduce the maintainence hassle.&lt;/li&gt;
&lt;li&gt;Gain confidence in the code by writing strong set of unit and end-to-end tests.&lt;/li&gt;
&lt;li&gt;Have a well organized build system (asset pipeline if you may) to manage these tasks and automate best practices.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;structure:476242b55cbd58e58bba92505cd1a3f6&#34;&gt;Structure&lt;/h3&gt;

&lt;p&gt;Before we get on the topic of structure, let me state my goal outright.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;My goal is here to have many Angular files in development, but they need to be loaded into the browser in bulk (as a single minified file).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;What that basically means is that I want to have many files in my local dev environment (I prefer to structure my app by function) but finally generate just a single file (preferably minfied) that can run in production.&lt;/p&gt;

&lt;p&gt;Burke Holland had a &lt;a href=&#34;http://developer.telerik.com/featured/requiring-vs-browerifying-angular/&#34;&gt;fantastic post&lt;/a&gt; explaining how Angular loads an application and comparing the merits of browserify vs require.js in an Angular app. As pointed out, RequireJS seems much more complicated in order to set it up with Angular apps. Instead of re-iterating his reasons here, I would extol you to go and give it a read yourself. Browserify, on the other hand does bring in some goodness of node.js modules in to browser but that also seemed like an overkill. Finally, reading over the comments on HN, I came across &lt;a href=&#34;https://news.ycombinator.com/item?id=8010997&#34;&gt;this comment&lt;/a&gt; by Burke Holland himself which basically switched on a light bulb in my head, and I decided to simply leverage Angular&amp;rsquo;s module system and do a concat on files before serving them to the browser.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I&amp;rsquo;m starting to think that module systems on Angular&amp;rsquo;s modules is a bad idea. Maybe I&amp;rsquo;m overthinking this. Should we just grunt-concat (or whatever Gulp does) and move on with life? - Burke Holland&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The simplest way is to organize your files is by functionality. Another popular method is to organize by application type eg. &lt;code&gt;login&lt;/code&gt;, &lt;code&gt;cart&lt;/code&gt; etc. With that in mind, this is how my current &lt;code&gt;src&lt;/code&gt; folder looks like -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├── app.js
├── controllers
│   ├── AddressController.js
│   ├── DeliveryController.js
│   ├── EditAddressController.js
│   ├── LoginController.js
│   └── NewAddressController.js
├── filters
│   └── LanguageFilters.js
└── services
    ├── AddressService.js
    ├── DeliveryService.js
    ├── CartService.js
    └── Constants.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, to make this work there is one small thing that needs to be kept in mind i.e. making sure your code uses Angular modules for declaration. So for example, instead of declaring a &lt;code&gt;factory&lt;/code&gt; like so&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var app = angular.module(&#39;myApp&#39;, [&#39;ngRoute&#39;]);

app.factory(&#39;CartService&#39;, function() {
  return {
    getItems: function() {},
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we should instead do this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;angular.module(&#39;myApp&#39;, [&#39;ngRoute&#39;]); // setter

angular.module(&#39;myApp&#39;) // getter 
  .factory(&#39;CartService&#39;, function() {
    return {
      getItems: function() {},
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are 2 problems with the first way.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;It adds the &lt;code&gt;app&lt;/code&gt; variable in the global scope. If you create another application that uses &lt;code&gt;app&lt;/code&gt; variable, this will be an issue.&lt;/li&gt;
&lt;li&gt;For the factory definition to work, the &lt;code&gt;app&lt;/code&gt; should already be defined. This creates, sort of a dependency, that needs to be tracked while concatenating.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The second way, however, faces none of the two flaws and allows you to be totally flexible in terms of ordering your declarations. With that done, here&amp;rsquo;s a simple grunt config that you can have to concat the &lt;code&gt;src&lt;/code&gt; files.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function(grunt) {

  // Project configuration.
  grunt.initConfig({
    pkg: grunt.file.readJSON(&#39;package.json&#39;),
    uglify: {
      options: {
	preserveComments: &#39;some&#39;,
	sourceMap: true
      },
      build: {
        src: &#39;build/main.js&#39;,
        dest: &#39;build/main.min.js&#39;
      }
    },
    concat: {
      options: {
        stripBanners: false,
        separator: &amp;quot;;&amp;quot;,
      },
      dist: {
        src: [&#39;src/**/*.js&#39;],
        dest: &amp;quot;build/main.js&amp;quot;
      }
    },
    watch: {
      scripts: {
        files: [&amp;quot;src/**/*.js&amp;quot;],
        tasks: [&#39;concat&#39;, &#39;uglify&#39;],
        options: {
          spawn: false
        },
      },
    },
  });

  // Load the plugins
  grunt.loadNpmTasks(&#39;grunt-contrib-concat&#39;);
  grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);
  grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;);

  // Default task(s).
  grunt.registerTask(&#39;default&#39;, [&#39;concat&#39;, &#39;uglify&#39;]);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The grunt file above contains three simple tasks - &lt;code&gt;uglify&lt;/code&gt;, &lt;code&gt;watch&lt;/code&gt;, &lt;code&gt;concat&lt;/code&gt;. Quite simply, the &lt;code&gt;concat&lt;/code&gt; task concatenates all the source files into a file located in &lt;code&gt;build&lt;/code&gt; folder. The &lt;code&gt;uglify&lt;/code&gt; task then takes the concatenated output and produces a minified js file along with a source map. [Source maps]() are an awesome feature in modern browsers that take the pain out of debugging minified javascript. I&amp;rsquo;ll be covering source maps in a separate article but until then you can go ahead and read [this]() article on HTML5 rocks to get a good gist on how they work. Finally, the &lt;code&gt;watch&lt;/code&gt; is a grunt task for the lazy that triggers a set of tasks (specified in &lt;code&gt;tasks&lt;/code&gt; array) to run whenever any file as mentioned in the &lt;code&gt;files&lt;/code&gt; options changes.&lt;/p&gt;

&lt;h3 id=&#34;testing:476242b55cbd58e58bba92505cd1a3f6&#34;&gt;Testing&lt;/h3&gt;

&lt;p&gt;With our angular app&amp;rsquo;s structure properly setup, lets get onto the fun stuff - testing. As with all apps, it is a good idea to write both unit and integration tests. One of the most awesome things about Angular is the fact that testing is treated as first-class citizen which is abundantly evident by the fantastic set of tools made available by the Angular team. These tools clearly take the pain out of setting up a test suite and the online docs provide a great starting point for writing robust set of tests. There are two specific testing tools that are typically used for testing Angular apps -&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://karma-runner.github.io/0.12/index.html&#34;&gt;Karma&lt;/a&gt; for unit tests&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/angular/protractor&#34;&gt;Protractor&lt;/a&gt; for end-to-end tests&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The preferred way of organizing tests is to keep the &lt;code&gt;e2e&lt;/code&gt; and &lt;code&gt;unit&lt;/code&gt; tests separate.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├── e2e
│   ├── delivery.spec.js
│   ├── index.spec.js
│   └── loginpage.spec.js
├── karma.conf.js
├── protractor.conf.js
├── server.js
└── unit
    ├── specs
    │   ├── delivery.spec.js
    └── vendorv
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;unit-tests-with-karma:476242b55cbd58e58bba92505cd1a3f6&#34;&gt;Unit tests with Karma&lt;/h4&gt;

&lt;p&gt;Karma is a test runner used and built by the Angular team to run unit tests. It has support for various testing frameworks like &lt;a href=&#34;http://visionmedia.github.io/mocha/&#34;&gt;Mocha&lt;/a&gt;, &lt;a href=&#34;http://jasmine.github.io/&#34;&gt;Jasmine&lt;/a&gt; etc. that help you write tests. Thanks to the power of dependancy injection and the modular nature of angular, writing unit tests to tests all parts of your application - from directives to controllers and services can be very easy.&lt;/p&gt;

&lt;p&gt;Karma requires a configuration file in order to run. &lt;a href=&#34;https://gist.github.com/prakhar1989/d38d6af5e1025a978c8c.js&#34;&gt;Here&amp;rsquo;s&lt;/a&gt; a sample configuration file that you can use to base your configuration off. The most important parts of the configuration are the &lt;code&gt;files&lt;/code&gt; and the &lt;code&gt;frameworks&lt;/code&gt; property.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// available frameworks: https://npmjs.org/browse/keyword/karma-adapter
frameworks: [&#39;jasmine&#39;],

// list of files / patterns to load in the browser
files: [
  &#39;tests/unit/vendor/angular.min.js&#39;,
  &#39;tests/unit/vendor/angular-mocks.js&#39;,
  &#39;src/filters/filters.js&#39;,
  &#39;src/services/DeliveryService.js&#39;,
  &#39;src/services/CartService.js&#39;,
  &#39;src/services/MessageService.js&#39;,
  &#39;tests/unit/specs/*.js&#39;
],
{% endhighlight %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Do make sure to include &lt;code&gt;angular.min.js&lt;/code&gt; and &lt;code&gt;angular-mocks.js&lt;/code&gt; or you&amp;rsquo;ll be beating yourself with incomprehensible error messages from Angular while running your tests. With that setup, you can run &lt;code&gt;karma start tests/karma.conf.js --single-run&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see how we can inject the angular app in karma tests. To illustrate, I am going to use the &lt;code&gt;deliveryService&lt;/code&gt; service and write tests for it.&lt;/p&gt;

&lt;p&gt;Delivery Service -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;angular.module(&#39;appServices.DeliveryService&#39;, [])
.factory(&#39;DeliveryService&#39;, function() {
  return {
    getDeliveryModes: function() { return {} }
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Delivery Spec -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;Service&#39;, function() {
  beforeEach(module(&#39;appServices.DeliveryService&#39;));

  describe(&#39;delivery service&#39;, function() {
    beforeEach(inject(function(DeliveryService) {
    // inject the service and do other things here
    }));

    it(&amp;quot;should get modes correctly&amp;quot;, inject(function(DeliveryService) {
      var deliveryInfo = DeliveryService.getDeliveryModes();
      expect(deliveryInfo).toEqual({});
    }));
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And with that, you have a fully functioning spec that you can test to your heart&amp;rsquo;s content.&lt;/p&gt;

&lt;h4 id=&#34;end-to-end-tests-with-protractor:476242b55cbd58e58bba92505cd1a3f6&#34;&gt;End-to-End tests with Protractor&lt;/h4&gt;

&lt;p&gt;From Protractor&amp;rsquo;s documentation - &lt;em&gt;Protractor is an end-to-end test framework for AngularJS applications. Protractor is a Node.js program built on top of WebDriverJS. Protractor runs tests against your application running in a real browser, interacting with it as a user would.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In other words, think of Protractor as Selenium with Angular goodness. For example, if you have a &lt;code&gt;input&lt;/code&gt; element like so&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;text&amp;quot; ng-model=&amp;quot;name&amp;quot; placeholder=&amp;quot;Enter Name&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then you can use use the &lt;code&gt;by.model&lt;/code&gt; selector to select the element, right within a protractor test spec&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;element(by.model(&#39;name&#39;)).sendKeys(1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pretty cool, right?&lt;/p&gt;

&lt;p&gt;Honestly, Protractor behaves just like an end-user and doesn&amp;rsquo;t give two hoots about how modular your application is. With protractor, you use a config file to tell the server address and you are done. Here&amp;rsquo;s a sample config file -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exports.config =  {
  seleniumAddress: &#39;http://127.0.0.1:4444/wd/hub&#39;,
    specs: [
    &amp;quot;./e2e/*.spec.js&amp;quot;
    ],
    suites: {
      login: &amp;quot;./e2e/loginpage.spec.js&amp;quot;,
      delivery: &amp;quot;./e2e/delivery.spec.js&amp;quot;
    },
    jasmineNodeOpts: {
      isVerbose: true,
      showColors: true,
      defaultTimeoutInterval: 5000
    },
    baseUrl: &amp;quot;http://localhost:8000&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Installing Protractor is quite simple. I&amp;rsquo;d suggest you quickly walk through the &lt;a href=&#34;https://github.com/angular/protractor/blob/master/docs/tutorial.md&#34;&gt;getting started page&lt;/a&gt; to setup everything.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:476242b55cbd58e58bba92505cd1a3f6&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Hopefully this (rather long) post has helped you in understanding how to organize your angular apps specifically for testing. Even if you dont plan to write tests, I&amp;rsquo;ve found this organization structure to be quite helpful and intuitive.&lt;/p&gt;

&lt;p&gt;If you feel I&amp;rsquo;ve missed out something or have some other tips to share - please feel free to share them in the comments below.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Choosing Angular</title>
      <link>http://192.241.186.225/articles/choosing-angular/</link>
      <pubDate>Sun, 06 Jul 2014 12:34:58 AST</pubDate>
      
      <guid>http://192.241.186.225/articles/choosing-angular/</guid>
      <description>&lt;p&gt;For the last couple of weeks I&amp;rsquo;ve spent a good deal of time on building a
brand new checkout for &lt;a href=&#34;http://www.xcite.com&#34;&gt;Xcite.com&lt;/a&gt;. Like other ecommerce
websites, our website has a conventional 3 step checkout - login/signup,
delivery and finally, payment. As a part of new project our goal is to allow
customers to checkout as guests i.e. without the need of creating an account
with Xcite. This allows us to reduce a step for customers who just want
quickly purchase something off the website and be on their way.&lt;/p&gt;

&lt;p&gt;Being an ecommerce website, user experience is something that is of paramount importance to us. Above all, the checkout process has to be smooth, easy and just work for the user. At any stage if the user is not satisfied, the website risks loosing the sale and all the dollars spent in bringing the user to the store, coaxing him to fill his basket go for naught.&lt;/p&gt;

&lt;p&gt;With that in mind, our focus has always been to make the checkout process as fluid as possible. The current process, for example, behaves as a &lt;a href=&#34;http://en.wikipedia.org/wiki/Single-page_application&#34;&gt;SPA (Single-page web app)&lt;/a&gt; and allows the user to seamlessly transition between the three steps and finally onto the payment gateway. However, from a software perspective it is a maintenance nightmare. The code powering the application is 2.5k lines of jQuery with tons of &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;bind&lt;/code&gt; and &lt;code&gt;trigger&lt;/code&gt; strewn in. Clearly, weilding jquery, which is great for DOM manipulation, is an absolute disaster for making a SPA where the UI is closely bound to the data.&lt;/p&gt;

&lt;figure&gt;
    &lt;a href=&#34;http://singlepageappbook.com&#34;&gt;&lt;img src=&#34;http://singlepageappbook.com/assets/overview.png&#34;&gt;&lt;/a&gt;
    &lt;figcaption&gt;&lt;a href=&#34;http://singlepageappbook.com/&#34; title=&#34;Single Page App Book&#34;&gt;Structure of modern SPAs. Courtesy - Single Page App Book&lt;/a&gt;.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;So finally when the chance to restructure the checkout process came in we decided to let of the jQuery baggage and rewrite the application in something more suited to our needs. Now the &lt;a href=&#34;http://programmers.stackexchange.com/questions/6268/when-is-a-big-rewrite-the-answer&#34;&gt;rewrite vs refactor&lt;/a&gt; debate is a long standing one in software engineering which I&amp;rsquo;m sure most of you are not alien to. Lots of words have been written, battles been fought and blood has been shed on the topic to decide whether the team should throw the technical baggage and begin afresh or should they try harder to carve a diamond out of existing coal.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;They did it by making the single worst strategic mistake that any software company can make: They decided to rewrite the code from scratch. - Joel Spolsky&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Joel makes a lot of well reasoned arguments in his &lt;a href=&#34;http://www.joelonsoftware.com/articles/fog0000000069.html&#34;&gt;article&lt;/a&gt; (which I suggest you should definitely read). In our case, however, our team had solid reasons in favour of a rewrite.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The existing code was written by a team which was no longer with the project. No one on the existing team had a strong understanding of how the code worked.&lt;/li&gt;
&lt;li&gt;Without any structure, the code was extremely hard to maintain and understand. Having a huge javascript file with more than 1500 lines of code was a complete nightmare.&lt;/li&gt;
&lt;li&gt;There were no tests at all which made refactoring a very hard exercise. Whenever a bug was reported the team used to be scared to break something that was already working.&lt;/li&gt;
&lt;li&gt;It used a technology (jQuery) which was totally not suited to the problem. This meant that adding any new features on the existing application would result in a lot more code which while using a better technology could be accomplished with much lesser.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In my opinion, these are very strong reasons that encourage a rewrite. With that out of the way, the next question on the team&amp;rsquo;s mind was which technology to pick. Javascript MVC frameworks have been cropping by the dozen and we wanted to be sure to pick something that was stable, battle-tested, had a strong community and ready help available.&lt;/p&gt;

&lt;p&gt;Being the only front-end engineer on the team, I had a strong say in choosing the framework to build the application on. Despite having substantial experience working with Backbone.js, given the complexity and needs of the checkout application, I was in favour of going for a framework that had, among other things, first class support for 2 way data binding.&lt;/p&gt;

&lt;p&gt;With these features in mind, it was not hard to make a choice and settle on &lt;a href=&#34;https://angularjs.org/&#34;&gt;Angularjs&lt;/a&gt;. With features like dependancy injection, 2 way data binding and awesome support for unit and end-to-end testing, Angular seemed like a great choice.&lt;/p&gt;

&lt;p&gt;In the next set of posts, I will talk more about what challenges I faced while building the new checkout application. I&amp;rsquo;m certainly hoping that I will have fun with Angular and learn something along the way!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Disclaimer: Views and opinions presented in this article are purely mine and do not represent those of my employer&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>