<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Swift on cat /dev/random</title>
    <link>http://localhost:1313/tags/swift/</link>
    <description>Recent content in Swift on cat /dev/random</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
    
    <lastBuildDate>Mon, 09 Jun 2014 12:34:58 AST</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/swift/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Swift - First Impressions</title>
      <link>http://localhost:1313/articles/swift-first-impressions/</link>
      <pubDate>Mon, 09 Jun 2014 12:34:58 AST</pubDate>
      
      <guid>http://localhost:1313/articles/swift-first-impressions/</guid>
      <description>

&lt;p&gt;Last week at WWDC Apple made the most exciting announcement (for developers at least) of launching a new programming language - Swift. Although I have never written a single line of code for iOS (in Objective C) I got so excited that within no time I was installing Xcode 6 to give playground &amp;amp; Swift a shot.&lt;/p&gt;

&lt;p&gt;After spending a week with Swift I&amp;rsquo;ve come to the conclusion that it is a very well designed programming language. For a Python/JS developer like me I was able to get productive very easily. It has strong remanents of Scala which is something I definitely I can&amp;rsquo;t dig enough.&lt;/p&gt;

&lt;p&gt;Below is a small list of features that I love the most about Swift. Consider this is an initial evaluation only, as I gain more experience I will blog about using Protocols, Enumerations and Generics with more practical examples.&lt;/p&gt;

&lt;h3 id=&#34;type-inference:9c765f6cd3c9cb3494c0676a5cd8e7b9&#34;&gt;Type Inference&lt;/h3&gt;

&lt;p&gt;One of the biggest inhibitions that developers with experience in dynamic languages like Python / Ruby have towards static compiled languages is the verbosity in the syntax. Repeatedly declaring &lt;code&gt;String name = &amp;quot;abc&amp;quot;&lt;/code&gt; and &lt;code&gt;int age = 23&lt;/code&gt; gets frustrating and it might make you think - why isn&amp;rsquo;t my computer smart enough to figure out that &lt;code&gt;23&lt;/code&gt; is indeed an integer. In Swift, this is as simple as&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let age = 23      // int
let name = &amp;quot;nasd&amp;quot; // string
let money = 23.3  // double
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Modern languages like Go embrace type inference and in my opinion it is one of reasons why Go saw an upsurge of adoption within the Python / Ruby community.&lt;/p&gt;

&lt;h3 id=&#34;optionals:9c765f6cd3c9cb3494c0676a5cd8e7b9&#34;&gt;Optionals&lt;/h3&gt;

&lt;p&gt;An optional value either contains a value or a &lt;code&gt;nil&lt;/code&gt; to indicate that a value is missing. I first learnt about the &lt;code&gt;Option&lt;/code&gt; type in Scala and the benefits of using a dedicated type for this became evident early on. Being a strongly typed language, Swift encourages using optionals to ensure safety.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# in the python world one would 
# do the following
msg = raw_prompt()
if msg {
  // raises a compile error
  print(msg + &amp;quot;, world&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While this is an accepted practice in lots of languages, the right way in Swift to do this is like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let msg: String? = &amp;quot;hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This tells the compiler that the variable &lt;code&gt;msg&lt;/code&gt; can have a value or be a &lt;code&gt;nil&lt;/code&gt;. Why is this awesome? I think this is definitely better than remembering the arcane rules other programming languages have. For example, in some cases a blank String is &lt;code&gt;truthy&lt;/code&gt; while in others it is &lt;code&gt;falsy&lt;/code&gt; e.g. Javascript. In PHP as an empty string is &lt;code&gt;falsy&lt;/code&gt; one would expect the string &lt;code&gt;&amp;quot;0&amp;quot;&lt;/code&gt; to be &lt;code&gt;truthy&lt;/code&gt; but its not &lt;em&gt;[this is because the &lt;code&gt;&amp;quot;0&amp;quot;&lt;/code&gt; is typecasted into a int]&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;How do you use it? Let us assume you have a &lt;code&gt;User&lt;/code&gt; object that stores information about a user and you define a collection that stores a collection of the &lt;code&gt;User&lt;/code&gt; object. You need to define a &lt;code&gt;findById&lt;/code&gt; function that returns the User object associated with that &lt;code&gt;id&lt;/code&gt;. Here&amp;rsquo;s how you can do it&lt;/p&gt;

&lt;p&gt;{% highlight scala %}
func findById(id: Int, users: User[]) -&amp;gt; User? {
  for u in Users {
    if u.id == id {
      return u
    }&lt;br /&gt;
  }
  return nil
}&lt;/p&gt;

&lt;p&gt;// user is bound to value in case nil is not returned
if let user = findById(1, users) {
  println(&amp;ldquo;user found: (user.name)&amp;ldquo;)
} else {
  println(&amp;ldquo;user not found&amp;rdquo;)
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;One last thing that might trip up beginners is the user &lt;code&gt;!&lt;/code&gt; to force unwrapping of the optional. Using a &lt;code&gt;!&lt;/code&gt; simply means that you&amp;rsquo;re sure the optional contains a value and you want to access it.&lt;/p&gt;

&lt;p&gt;{% highlight scala %}
if findById(1, users) {
  println(&amp;ldquo;user found: (findById(1, users)!.name)&amp;ldquo;)
} else {
  println(&amp;ldquo;user not found&amp;rdquo;)
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Having optionals helps you keep your mind free from all these rules and helps eliminate potential bugs.&lt;/p&gt;

&lt;h3 id=&#34;ranges:9c765f6cd3c9cb3494c0676a5cd8e7b9&#34;&gt;Ranges&lt;/h3&gt;

&lt;p&gt;Very simple and straightforward - ranges are my most preferred way of iterating through a collection of integers. Ranges are present in both Python and Ruby, and I&amp;rsquo;d be lying if I say that I don&amp;rsquo;t miss them in Javascript.&lt;/p&gt;

&lt;p&gt;{% highlight scala %}
// Swift
for i in 0..10 {
  println(i)
}&lt;/p&gt;

&lt;p&gt;// Python
for i in range(0, 10) {
  print(i)
}&lt;/p&gt;

&lt;p&gt;// Ruby
for i in 0..10 {
  print i
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Unfortunately usage of ranges in Go are different from the example above. Since there&amp;rsquo;s no way to create an array (or a slice) by just specifying the start and end of the collection, &lt;code&gt;Range(1,20)&lt;/code&gt; doesn&amp;rsquo;t work. From the &lt;a href=&#34;http://golang.org/ref/spec#RangeClause&#34;&gt;documentation&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The expression on the right in the &amp;ldquo;range&amp;rdquo; clause is called the range expression, which may be an array, pointer to an array, slice, string, map, or channel permitting receive operations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;One thing that both Go and Swift share (w.r.t. ranges) is ignoring values using the &lt;code&gt;_&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;{% highlight scala %}
var (n, answer, base) = (4, 10, 2)
for _ in 0..n {
  answer += base
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;This is a nice-to-have feature if you don&amp;rsquo;t want to populate the local namespace.&lt;/p&gt;

&lt;h3 id=&#34;closures:9c765f6cd3c9cb3494c0676a5cd8e7b9&#34;&gt;Closures&lt;/h3&gt;

&lt;p&gt;If you have any Javascript experience under your belt, chances are you have used closures. Closures are common in languages in which functions are treated as first-class citizens. I&amp;rsquo;ll not go into details of explaining what closures are but to put it in one line - they are self-contained blocks of code that can be passed around your code. Closures basically capture or &lt;em&gt;close&lt;/em&gt; the values of the data from the context in which they were defined.&lt;/p&gt;

&lt;p&gt;Swift allows a lot of syntactic sugar when it comes to closures, making them a joy to use. The 4 primary features are&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Inferring parameter and return value types from context.&lt;/li&gt;
&lt;li&gt;Implicit returns from single-expression closures&lt;/li&gt;
&lt;li&gt;Shorthand argument names&lt;/li&gt;
&lt;li&gt;Trailing closure syntax&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let me illustrate the points below with a practical example. We will use the &lt;code&gt;sort&lt;/code&gt; function which takes a collection and a function (closure) on which the function is sorted.&lt;/p&gt;

&lt;p&gt;{% highlight scala %}
let fruits = [&amp;ldquo;apples&amp;rdquo;, &amp;ldquo;oranges&amp;rdquo;, &amp;ldquo;banana&amp;rdquo;, &amp;ldquo;pear&amp;rdquo;]&lt;/p&gt;

&lt;p&gt;func longest(s1: String, s2: String) -&amp;gt; Bool {
  return countElements(s1) &amp;gt; countElements(s2)
}&lt;/p&gt;

&lt;p&gt;// returns [&amp;ldquo;oranges&amp;rdquo;, &amp;ldquo;banana&amp;rdquo;, &amp;ldquo;apples&amp;rdquo;, &amp;ldquo;pear&amp;rdquo;]
sort(fruits, longest)
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;The equivalent closure for to accomplish the above would be -
{% highlight scala %}
sort(fruits, { (s1: String, s2: String) -&amp;gt; Bool in
  return countElements(s1) &amp;gt; countElements(s2)
})
{% endhighlight %}
The code after &lt;code&gt;in&lt;/code&gt; begins the closure. We will see how the features provided by Swift makes it much much easier to do the same thing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Inferring parameter and return value types from context&lt;/strong&gt;.
{% highlight scala %}
// removing the type information
sort(fruits, { (s1, s2) in
  return countElements(s1) &amp;gt; countElements(s2)
})
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Implicit returns from single-expression closures&lt;/strong&gt;
{% highlight scala %}
// remove the explicit return
sort(fruits, { (s1, s2) in&lt;br /&gt;
  countElements(s1) &amp;gt; countElements(s2)
})
{% endhighlight %}
&lt;strong&gt;Shorthand argument names&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;{% highlight scala %}
// $0 refers to the first arg, $1 refers to the second
sort(fruits, { countElements($0) &amp;gt; countElements($1) })
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Trailing closure syntax&lt;/strong&gt;
{% highlight scala %}
// syntactic sugar to allow passing a closure outside of a function call
sort(fruits) { countElements($0) &amp;gt; countElements($1) }
{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;map-filter-and-reduce:9c765f6cd3c9cb3494c0676a5cd8e7b9&#34;&gt;Map, Filter and Reduce&lt;/h3&gt;

&lt;p&gt;Directly incorporated from the functional programming world, the functions &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; are available on all collections to help you iterate through a collection, perform an operation and return a new collection. The syntax is similar to closure so it is quite intuitive once you get a hang of it.&lt;/p&gt;

&lt;p&gt;{% highlight scala %}
let numbers = [12, 49, 23, 44, 143]&lt;/p&gt;

&lt;p&gt;let squares = numbers.map { $0 * $0 } // squares of numbers
// squares [144, 2401, 529, 1936, 20449]&lt;/p&gt;

&lt;p&gt;let even = numbers.filter { $0 % 2 == 0}  // filter all even
// even [12, 44]&lt;/p&gt;

&lt;p&gt;let sum = numbers.reduce(0, combine: {$0 + $1}) // finding the sum of the elements
// sum 271
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;If you haven&amp;rsquo;t tried Swift yet, I encourage you to give it a shot. Its a fun language and Apple&amp;rsquo;s building a great ecosystem around it. Expect people to share their playground files with cool demos once Xcode 6 becomes stable. I am super excited to see what the future holds!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>